<!-- Autogenerated guidance for AI coding agents working in this repository. Keep concise and actionable. -->
# Copilot instructions for azuredev-4c13

Purpose
- This repo contains a small starter project for running multi-threaded Azure AI Foundry agents locally. The goal is to run generator, selector and verifier threads that cooperate on a task (the template used for GPT-5 mini threaded agents).

Quick start (developer / agent)
- Install Python deps: `pip install -r requirements.txt`
- Put your Azure Foundry endpoint and an agent id into `agents/config.py` (replace `ENDPOINT` and `AGENT_ID`).
- Ensure credentials available for `DefaultAzureCredential` (Azure CLI signed in, environment variables for a service principal, or managed identity).
- Run the simple runner: `python agents/run_agent.py "Hello Agent"` or the top-level helper: `python run_agent.py`.

Key components and patterns (read these files)
- `agents/config.py` — contains the FOUNDARY `ENDPOINT` and `AGENT_ID` the scripts use. Update for each environment.
- `agents/run_agent.py` — safe local runner. Creates a thread, sends a system/user message, calls `create_and_process` and polls for status. Example: create thread -> `project.agents.messages.create(thread_id, role="system", ...)` -> `create_and_process`.
- `agents/generate_ensemble.py` — runs multiple generator variants in parallel (ThreadPoolExecutor). Variants are implemented by injecting different `system` messages before the user prompt. The reranker presently prefers succeeded runs and the longest textual reply.
- `agents/selector.py` — rule-based selector that decides whether to call the generator. Uses `compress_context()` and `should_generate()` heuristics. Replace with a selector agent if needed.
- `agents/verifier.py` — deterministic verifier for candidate responses. Looks for secrets, expects unified diff patches when returning `patch` fields, and can optionally call linters (flake8). Returns `{"verdict": "PASS"|"FAIL", "issues": [...], "confidence": n}`.

Message and thread conventions
- Threads are created via `project.agents.threads.create()` and identified by `thread.id`.
- Send `system` messages first to set behavior, then `user` messages. Many scripts rely on that ordering (see `generate_ensemble._single_variant`).
- Read messages using `project.agents.messages.list(thread_id=..., order=ListSortOrder.ASCENDING)` and access textual content with `m.text_messages[-1].text.value`.
- Create a run with `project.agents.runs.create_and_process(thread_id=..., agent_id=...)` and poll `run.status` until `succeeded` or `failed`.

Ensemble / orchestration notes
- The ensemble pattern here: multiple variants (different system prompts) -> run in parallel -> rerank. This file is the simplest place to change orchestration logic or replace the reranker with the `verifier`.
- Use `agents/verifier.py` to gate patches before applying them. The verifier expects unified diffs when `patch` is present (look for `diff --git` or `--- a/`).

Security and safety patterns
- `verifier.find_secrets` already looks for common secret patterns; do not hard-code secrets into code. `agents/config.py` is expected to contain non-sensitive configuration only — keep secrets in environment variables or a secrets store.

Developer workflows & useful commands (Windows / PowerShell)
- Install dependencies: `pip install -r requirements.txt`
- Run a one-off prompt: `python agents/run_agent.py "Fix test foo"`
- Generate an ensemble: `python agents/generate_ensemble.py "Fix test foo" --workers 3`
- If you need to configure credentials in PowerShell for `DefaultAzureCredential` using a service principal:
  - $env:AZURE_CLIENT_ID = '...'
  - $env:AZURE_TENANT_ID = '...'
  - $env:AZURE_CLIENT_SECRET = '...'

Repository-specific conventions
- System-message-first: many helpers inject a `system` message prior to the `user` prompt to control agent behavior.
- Patch format: when code fixes are produced, scripts expect unified-diff style patches (verifier checks for these).
- Simple rule-based selector: `agents/selector.py` is intentionally conservative. If you switch to a model-based selector, preserve the same decision API: return `{"route": "GENERATE"|"NO_OP"|"REFINE", "confidence": float}`.

Where to extend for GPT-5-mini threaded orchestration
- Implement thread activation: call `agents/selector.should_generate()` to decide whether to kick generator threads.
- Use `agents/generate_ensemble.generate_ensemble()` to run multiple generator threads; replace reranker with calls to `agents/verifier.verify_candidate()` to pick the safest candidate.
- Use `agents/run_agent.py` as a canonical example of polling `runs` and collecting messages.

Files worth reading next
- `README.md` (top-level) — environment hints.
- `agents/run_agent.py`, `agents/generate_ensemble.py`, `agents/selector.py`, `agents/verifier.py`, `agents/config.py` — primary agent logic.
- `extension/` — contains a small extension scaffold (package.json, tsconfig.json) if you plan to add a UI.

New helpers
- `agents/thread_templates.py` — helper templates and utilities to create and run threads. Use `init_thread()` and `run_agent_once()` to standardize system->user ordering and polling.
- `agents/cli.py` — lightweight CLI wrapper to create a thread from a named template and run it; useful for local, repeatable tests and CI.

Testing
- Unit tests use the standard library `unittest`. Run them with:
  - `python -m unittest discover -v`
- Tests intentionally mock `agents.thread_templates.create_client` to avoid network calls. See `tests/test_cli.py` for patterns to mock `init_thread`, `run_agent_once`, and `collect_messages`.

If anything in these instructions is unclear or missing, tell me which part to expand or a specific workflow to document.
